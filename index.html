<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Eternal Rose üåπ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a0505, #000000);
            font-family: 'Cinzel Decorative', serif;
        }

        #ui-layer {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #ff3366;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px #ff0033;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            letter-spacing: 5px;
            opacity: 0;
            animation: glowFade 4s infinite alternate;
        }

        @keyframes glowFade {
            0% { opacity: 0.6; text-shadow: 0 0 10px #ff0033; }
            100% { opacity: 1; text-shadow: 0 0 30px #ff0033, 0 0 60px #ff0033; }
        }

        #instruction {
            font-size: 0.9rem;
            color: #884444;
            margin-top: 10px;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>For You, Always</h1>
        <div id="instruction">Move your mouse to light up the magic <br/>Ravikant - made with Loveü§ç</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- 2. MATERIALS ---
        
        // Rose Petal (Velvet Red)
        const petalMat = new THREE.MeshPhysicalMaterial({
            color: 0xff0033,
            roughness: 0.6,
            metalness: 0.1,
            sheen: 1.0,
            sheenColor: 0xffaaaa,
            clearcoat: 0.1,
            side: THREE.DoubleSide
        });

        // Stem/Leaf (Dark Green)
        const stemMat = new THREE.MeshStandardMaterial({
            color: 0x228822,
            roughness: 0.8
        });

        // Glass Dome (Transparent & Reflective)
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0,
            roughness: 0,
            transmission: 0.95, // Glass transparency
            thickness: 0.1,
            ior: 1.5,
            clearcoat: 1.0,
            transparent: true,
            opacity: 0.3
        });

        // Base (Gold/Wood)
        const baseMat = new THREE.MeshStandardMaterial({
            color: 0x331100, // Dark wood
            roughness: 0.6,
        });

        // --- 3. CONSTRUCTING THE ROSE ---
        const roseGroup = new THREE.Group();
        scene.add(roseGroup);

        // A. The Flower Head (Procedural Petals)
        const flowerHead = new THREE.Group();
        flowerHead.position.y = 2.5;
        // Tilt slightly for beauty
        flowerHead.rotation.z = 0.2; 
        roseGroup.add(flowerHead);

        // Inner bud
        const budGeo = new THREE.ConeGeometry(0.3, 0.8, 32, 1, true);
        const bud = new THREE.Mesh(budGeo, petalMat);
        bud.rotation.x = Math.PI;
        flowerHead.add(bud);

        // Function to add layers of petals
        function addPetalLayer(count, radius, tilt, height, scaleW) {
            for(let i=0; i<count; i++) {
                // Shape a petal using a sphere segment
                const geo = new THREE.SphereGeometry(0.5, 16, 16, 0, Math.PI*2, 0, Math.PI/2.5);
                // Flatten slightly
                geo.scale(scaleW, 1, 0.2); 
                
                const petal = new THREE.Mesh(geo, petalMat);
                
                // Position in circle
                const angle = (i / count) * Math.PI * 2;
                petal.position.x = Math.sin(angle) * radius * 0.5;
                petal.position.z = Math.cos(angle) * radius * 0.5;
                petal.position.y = height;

                // Rotate to face outward
                petal.rotation.y = angle;
                // Tilt backward to open up
                petal.rotation.x = tilt;

                flowerHead.add(petal);
            }
        }

        // Layer 1: Tight
        addPetalLayer(3, 0.4, 0.2, 0.1, 0.6);
        // Layer 2: Opening
        addPetalLayer(5, 0.7, 0.5, 0.0, 0.8);
        // Layer 3: Bloom
        addPetalLayer(6, 1.0, 0.9, -0.1, 1.0);
        // Layer 4: Wide
        addPetalLayer(7, 1.3, 1.2, -0.2, 1.1);

        // B. Stem
        const stemCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0.1, 1, 0),
            new THREE.Vector3(-0.1, 2, 0.1),
            new THREE.Vector3(0, 2.5, 0)
        ]);
        const stemGeo = new THREE.TubeGeometry(stemCurve, 20, 0.08, 8, false);
        const stem = new THREE.Mesh(stemGeo, stemMat);
        roseGroup.add(stem);

        // C. Thorns
        const thornGeo = new THREE.ConeGeometry(0.05, 0.2, 8);
        const thorn1 = new THREE.Mesh(thornGeo, stemMat);
        thorn1.position.set(0.08, 1.2, 0);
        thorn1.rotation.z = -1;
        roseGroup.add(thorn1);

        const thorn2 = new THREE.Mesh(thornGeo, stemMat);
        thorn2.position.set(-0.08, 0.6, 0.05);
        thorn2.rotation.z = 1;
        roseGroup.add(thorn2);

        // D. Leaf
        const leafGeo = new THREE.SphereGeometry(0.3, 16, 16);
        leafGeo.scale(1, 0.1, 1.5); // Flatten and stretch
        const leaf = new THREE.Mesh(leafGeo, stemMat);
        leaf.position.set(0.1, 1.5, 0);
        leaf.rotation.x = 0.5;
        leaf.rotation.z = -0.5;
        roseGroup.add(leaf);


        // --- 4. THE GLASS DOME & BASE ---
        
        // Base
        const baseGeo = new THREE.CylinderGeometry(2.2, 2.4, 0.5, 64);
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = -0.25;
        base.receiveShadow = true;
        scene.add(base);

        // Dome
        const domeGeo = new THREE.CapsuleGeometry(2, 4, 4, 32);
        const dome = new THREE.Mesh(domeGeo, glassMat);
        dome.position.y = 2.0;
        scene.add(dome);

        // Interior Sparkles (Magic Dust)
        const particlesGeo = new THREE.BufferGeometry();
        const pCount = 100;
        const pPos = new Float32Array(pCount * 3);
        for(let i=0; i<pCount*3; i+=3) {
            const r = Math.random() * 1.5;
            const theta = Math.random() * Math.PI * 2;
            const y = Math.random() * 3.5;
            pPos[i] = Math.cos(theta) * r;
            pPos[i+1] = y;
            pPos[i+2] = Math.sin(theta) * r;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particlesMat = new THREE.PointsMaterial({
            color: 0xffcc00,
            size: 0.05,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const sparkles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(sparkles);


        // --- 5. LIGHTING ---
        
        const ambient = new THREE.AmbientLight(0x220000, 1);
        scene.add(ambient);

        const roseLight = new THREE.PointLight(0xff0055, 2, 5);
        roseLight.position.set(0, 2.5, 0);
        scene.add(roseLight);

        // Increased Spotlight intensity slightly
        const spotLight = new THREE.SpotLight(0xffddaa, 15);
        spotLight.position.set(5, 8, 5);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        const rimLight = new THREE.SpotLight(0x0044ff, 5);
        rimLight.position.set(-5, 5, -5);
        rimLight.lookAt(0, 2, 0);
        scene.add(rimLight);

        // NEW: Magical Cursor Light
        const cursorLight = new THREE.PointLight(0xffffff, 30, 10); // Bright, decaying light
        scene.add(cursorLight);

        // NEW: Tiny glowing orb attached to the cursor light so you can see it
        const cursorOrbGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const cursorOrbMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const cursorOrb = new THREE.Mesh(cursorOrbGeo, cursorOrbMat);
        scene.add(cursorOrb);


        // --- 6. FALLING PETALS ANIMATION ---
        
        const loosePetals = [];
        const lpGeo = new THREE.SphereGeometry(0.2, 8, 8, 0, Math.PI*2, 0, Math.PI/2);
        lpGeo.scale(1, 0.2, 1);
        
        for(let i=0; i<3; i++) {
            const lp = new THREE.Mesh(lpGeo, petalMat);
            lp.position.set((Math.random()-0.5)*1.5, 0.05, (Math.random()-0.5)*1.5);
            lp.rotation.x = -Math.PI/2;
            lp.rotation.z = Math.random() * Math.PI;
            scene.add(lp);
            loosePetals.push(lp);
        }

        // --- 7. ANIMATION LOOP ---
        
        let mouseX = 0;
        let mouseY = 0;
        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Rotate the whole rose slowly
            roseGroup.rotation.y = Math.sin(time * 0.2) * 0.1;

            // Pulse the inner light
            roseLight.intensity = 1.5 + Math.sin(time * 2) * 0.5;

            // Move Sparkles
            const positions = sparkles.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.002;
                if(positions[i] < 0) positions[i] = 3.5;
            }
            sparkles.geometry.attributes.position.needsUpdate = true;
            sparkles.rotation.y = time * 0.1;

            // Interactive Lighting - SpotLight loosely follows
            spotLight.position.x += (mouseX * 10 - spotLight.position.x) * 0.05;
            spotLight.position.y += (mouseY * 5 + 8 - spotLight.position.y) * 0.05;

            // NEW: Magic Cursor Light strongly follows mouse exact coordinates
            // Map 2D mouse coordinates to our 3D space limits
            const targetCursorX = mouseX * 6;  // Range: Left to Right
            const targetCursorY = mouseY * 4 + 3; // Range: Up and Down centered on the rose
            const targetCursorZ = 3.5; // Stay just outside the glass dome

            // Lerp (smooth movement) towards the mouse target
            cursorLight.position.x += (targetCursorX - cursorLight.position.x) * 0.1;
            cursorLight.position.y += (targetCursorY - cursorLight.position.y) * 0.1;
            cursorLight.position.z = targetCursorZ;

            // Snap the visual orb to the light's exact position
            cursorOrb.position.copy(cursorLight.position);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>